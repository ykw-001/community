### 一、MySql

1.存储引擎：选择InnoDB，因为它支持事务，它还支持外键；NDB支持集群，但一般不用。

2.事务：

​	（1）特性：原子性、一致性、隔离性、持久性

​	（2）各个特性的理解：

​				1）原子性：一个事务要么全部执行完成,要么在执行过程发生错误后产生回滚(回滚:数据恢复到事务开始之前,不产生改变),不会存在执行一半就结束的情况。

​				2）一致性：事务开始到事务结束数据库的完整性没有被破坏，也可以理解为事务从一个正确的状态迁移到另一个正确的状态，也就是所有写入的数据都符合之前设定的规则。

​				3）持久性：事务一旦成功执行完成,也就是没有发生回滚，那么它对数据的修改就是永久的，即使现在系统发生故障也不会丢失数据。

​				4）隔离性：

​						a.并发异常：第一类丢失更新、第二类丢失更新、脏读、幻读、不可重复读

​						b.隔离级别：读未提交<读已提交<可重复读（mysql默认级别）<可串行化

​	 （3）锁

​				1）范围：

​						a.表级锁：开销小、加锁快、发生锁冲突的概率高、并发度低、不会出现死锁

​						b.行级锁：开销大、加锁慢、发生锁冲突的概率低、并发度高、会出现死锁

​				2）类型（InnoDB）：

​						a.共享锁（s）：行级、读取一行，加了这个不能加IX、X锁

​						b.排它锁（x）：行级、更新一行，加了这个不能加其它所有锁

​						c.意向共享锁（IS）：表级、准备加共享锁，加了这个后不能加X锁

​						d.意向排它锁（IX）：表级、准备加排它锁，加了这个不能加S、X锁

​						e.间隙锁（NK）：行级，使用范围条件时对范围内不存在的记录加锁。一是为了防止					幻读，二是为了满足恢复和复制的需求。

​				3）加锁：

​						a.增加行级锁之前，InnoDB会自动给表加意向锁

​						b.执行DML（数据操纵语言，包括检索和更新）语句时，InnoDB会自动给数据加排它					锁。

​						c.执行DQL（数据查询语言）语句时：

​							-共享锁（S）：SELECT ... FROM .. WHERE ... LOCK IN SHARE MODE;

​							-排它锁（X）：SELECT ... FROM ... WHERE ... FOR UPDATE;

​							-间隙锁（NK）：上诉SQL采用范围条件时，InnoDB自动对不存在的记录增加。

```mysql
SELECT 要查询的列名
FROM 基本表名 			# 要查询的基本表名字
WHERE 限定条件			# 条件限定语句，用来筛选符合条件的记录
GROUP BY 分组列		# 按照分组列分组，比如说按照部门列分组，分组之后一个部门是一条记录
HAVING 限定条件			# 分组之后的条件，可以按照这个条件筛选分组之后的结果
ORDER BY 排序规则		# 按照排序规则对结果集进行排序
LIMIT 开始下标，结果数量;	# 显示指定条数的结果记录 
```

​				4）死锁：

​						a.解决方案：

​								一般InnoDB会自动检测到，并使一个事务回滚，另一个事务继续

​								设置超时等待参数innodb_lock_wait_timeout；

​						b.避免死锁

​								不同业务并发访问多个表时，应约定以相同的顺序来访问这些表

​								以批量的方式处理数据时，应事先对数据排序，保证线程按固定的顺序来处理

​								在事务中，若要更新记录，应直接申请排他锁

3.悲观锁（数据库里的锁都是）

4.乐观锁（自定义）

​		（1）版本号机制

```mysql
UPDATE ... SET ..., VERSION=#{version+1}WHERE ... AND VERSION=${version}
```

​		（2）CVS算法（Compare   and   Swap）

5.索引（InnoDB采用B+Tree完成索引）

​		（1）数据分块存储，每一块为一页；

​		（2）所有值按顺序存储，且每一个叶子到根的距离相同；

​		（3）非叶节点存储数据的边界，叶子节点存储指向数据行的指针；

​		（4）通过边界缩小数据的范围，从而避免全表扫描，加快查找速度。

### 二、Redis

1.数据类型：

​	（1）key：512M

​	（2）string：512M

​	（3）hash：2^32 - 1

​	（4）list：2^32 - 1

​	（5）set：2^32 - 1

​	（6）sorted set

​	（7）bitmap：512M

​	（8）hyperloglog：12K

2.过期策略：Redis会把设置了过期时间的key放进一个独立的字典中，在key过期时不会立刻删除。删除过期key有两种策略：

​	（1）惰性删除：客户端访问某个key时，Redis会检查该key是否过期，若过期这删除

​	（2）定期扫描：

​			1）默认每秒执行10次过期扫描（配置hz选项）

​					a.从过期字典中随机选择20个key；

​					b.删除这个20个key中已过期的key；

​					c.若过期key比例超过25%，重复步骤1；

3.缓存穿透

​	（1）解决方案

​			1）缓存空对象

​			2）布隆过滤器

4.缓存击穿

​	（1）解决方案

​			1）加互斥锁

​			2）永不过期：不设置过期时间，为每个value值设置逻辑过期时间，发现该值逻辑过期时，		使用单独的线程重建缓存。

5.缓存雪崩

​	（1）解决方案

​			1）避免同时过期

​			2）构建高可用的Redis缓存

​			3）构建多级缓存

​			4）启用限流和降级措施

6.分布式锁

​	（1）基本原理

​				1）同步锁：在多个线程都能访问到的地方，做一个标记，标识该数据的访问权限

​				2）分布式锁：在多个进程都能访问到的地方，做一个标记，标识该数据的访问权限

​	（2）实现方式

​				1）基于数据库实现

​				2）基于Redis实现

​	（3）实现原则

​				1）安全属性：独享，任意时刻，只有一个客户端持有锁

​				2）活性A：无死锁，即使持有锁的客户端崩溃或者网络被分裂，锁仍然可以被获取

​				3）活性B：容错，只要大部分Redis节点都或者，客户端就可以获取和释放锁

### 三、Spring

1.Bean的作用域：

​	（1）singleton：范围是所有Spring应用，为默认值

​	（2）prototype：范围是所有Sping应用，在容器中存在多个实例，即每次获取该Bean是，都会	创建一个新实例。

​	（3）request：Spring Web应用，为每个请求创建一个新实例

​	（4）session：Spring Web应用，为每个会话创建一个新实例

​	（5）globalSession：Sping Web应用，为全局session创建一个实例，只在Portlet中有效

​	（6）application：Spring Web应用，为整个Web应用创建一个新实例

2.工作流程

客户端发出请求访问服务器 ----- DispatcherServlet处理请求 ------ 调用HandlerMapping根据访问路径找到controller ------ HandlerExecutionChain封装拦截器以及响应路径 ------ 返回封装给DispatcherServlet ------ preHandle（）拦截器 ------ HandlerAdapter ------ ModelAndView ------- postHandler（）拦截器 ------ 将数据交给DispatcherServlet封装 ------ 数据给如ViewResolver进行处理解析 ------ 交给View视图，找到对应模板，让模板引擎进行渲染 ------- 调用afterCompletion（）清除数据 ------ 返回客户端可视视图

